diff --git a/Makefile b/Makefile
index 0b12e7e..bf4016d 100644
--- a/Makefile
+++ b/Makefile
@@ -18,9 +18,13 @@ coverage: ## Runs coverage tests for MumbleDJ.
 clean: ## Removes compiled MumbleDJ binaries.
 	@rm -f mumbledj*
 
+.PHONY: remove
+remove: ## Removes compiled MumbleDJ binaries.
+	@rm -f ../../../../bin/mumbledj
+
 .PHONY: install
 install: ## Copies MumbleDJ binary to /usr/local/bin for easy execution.
-	@cp -f mumbledj* /usr/local/bin/mumbledj
+	@cp -f mumbledj* ../../../../bin/mumbledj
 
 .PHONY: dist
 dist: ## Performs cross-platform builds via gox for multiple Linux platforms.
diff --git a/bot/config.go b/bot/config.go
index 17f6d12..94d4030 100644
--- a/bot/config.go
+++ b/bot/config.go
@@ -80,6 +80,26 @@ func SetDefaultConfig() {
 	viper.SetDefault("commands.add.messages.many_tracks_added", "<b>%s</b> added <b>%d</b> tracks to the queue.")
 	viper.SetDefault("commands.add.messages.num_tracks_too_long", "<br><b>%d</b> tracks could not be added due to error or because they are too long.")
 
+	viper.SetDefault("commands.songs.aliases", []string{"songs", "tracks","muzyka"})
+	viper.SetDefault("commands.songs.is_admin", false)
+	viper.SetDefault("commands.songs.description", "List of songs with commands instead of links to yt.")
+
+	viper.SetDefault("commands.wstan.aliases", []string{"wstan","powiedzzeniejestessam"})
+	viper.SetDefault("commands.wstan.is_admin", false)
+	viper.SetDefault("commands.wstan.description", "Best songs lyrics")
+	viper.SetDefault("commands.wstan.messages.list", "costam")
+
+	viper.SetDefault("commands.addsong.aliases", []string{"addsong","as"})
+	viper.SetDefault("commands.addsong.is_admin", true)
+	viper.SetDefault("commands.addsong.description", "Do not break the syntax!")
+	viper.SetDefault("commands.addsong.messages.success", "Probably added.")
+	viper.SetDefault("commands.addsong.messages.syntax_error", "Syntax is: addsong TAG URL")
+
+	viper.SetDefault("commands.text.aliases", []string{"text","tekst","lyrics"})
+	viper.SetDefault("commands.text.is_admin", false)
+	viper.SetDefault("commands.text.description", "Do not break the syntax!")
+	viper.SetDefault("commands.text.messages.syntax_error", "Syntax is: text ARTIST SONGNAME")
+
 	viper.SetDefault("commands.addnext.aliases", []string{"addnext", "an"})
 	viper.SetDefault("commands.addnext.is_admin", true)
 	viper.SetDefault("commands.addnext.description", "Adds a track or playlist from a media site as the next item in the queue.")
diff --git a/commands/add.go b/commands/add.go
index 9466e3c..a97edca 100644
--- a/commands/add.go
+++ b/commands/add.go
@@ -10,6 +10,8 @@ package commands
 import (
 	"errors"
 	"fmt"
+	"strings"
+	"io/ioutil"
 
 	"github.com/layeh/gumble/gumble"
 	"github.com/matthieugrieger/mumbledj/interfaces"
@@ -58,7 +60,20 @@ func (c *AddCommand) Execute(user *gumble.User, args ...string) (string, bool, e
 		return "", true, errors.New(viper.GetString("commands.add.messages.no_url_error"))
 	}
 
+	file, _ := ioutil.ReadFile("/home/mumbledj/songurls.txt")
+	strArray := strings.Split(string(file), "\n")
+	strArray = strArray[0:len(strArray)-1]
+
 	for _, arg := range args {
+		if( !strings.Contains(arg, "www.youtube.com") ){
+			for _, strln := range strArray{
+				s:= strings.Split(strln, " ")
+				tag, url := s[0], s[1]
+				if(arg==tag){
+					arg=url
+				}
+			}
+		}
 		if service, err = DJ.GetService(arg); err == nil {
 			tracks, err = service.GetTracks(arg, user)
 			if err == nil {
diff --git a/commands/pkg_init.go b/commands/pkg_init.go
index 13a7dbd..f2ea6a4 100644
--- a/commands/pkg_init.go
+++ b/commands/pkg_init.go
@@ -46,5 +46,10 @@ func init() {
 		new(ToggleShuffleCommand),
 		new(VersionCommand),
 		new(VolumeCommand),
+		new(SongsCommand),
+		new(WstanCommand),
+		new(AddSongCommand),
+		new(TextCommand),
+		new(ShuffleCommand),
 	}
 }
diff --git a/commands/shuffle.go b/commands/shuffle.go
index 61f6a8f..32c7c96 100644
--- a/commands/shuffle.go
+++ b/commands/shuffle.go
@@ -1,7 +1,7 @@
 /*
- * MumbleDJ
+ * mumbledj
  * By Matthieu Grieger
- * commands/shuffle.go
+ * commands/add.go
  * Copyright (c) 2016 Matthieu Grieger (MIT License)
  */
 
@@ -9,12 +9,17 @@ package commands
 
 import (
 	"errors"
+	"fmt"
+	"strings"
+	"io/ioutil"
+	"math/rand"
+	"time"
 
 	"github.com/layeh/gumble/gumble"
+	"github.com/matthieugrieger/mumbledj/interfaces"
 	"github.com/spf13/viper"
 )
 
-// ShuffleCommand is a command that shuffles the audio queue.
 type ShuffleCommand struct{}
 
 // Aliases returns the current aliases for the command.
@@ -43,15 +48,69 @@ func (c *ShuffleCommand) IsAdminCommand() bool {
 // Example return statement:
 //    return "This is a private message!", true, nil
 func (c *ShuffleCommand) Execute(user *gumble.User, args ...string) (string, bool, error) {
-	length := DJ.Queue.Length()
-	if length == 0 {
-		return "", true, errors.New(viper.GetString("commands.common_messages.no_tracks_error"))
+	var (
+		allTracks      []interfaces.Track
+		tracks         []interfaces.Track
+		service        interfaces.Service
+		err            error
+		lastTrackAdded interfaces.Track
+	)
+
+	if len(args) != 0 {
+		return "", true, errors.New(viper.GetString("commands.shuffle.messages.url_error"))
+	}
+
+	file, _ := ioutil.ReadFile("/home/mumbledj/songurls.txt")
+	strArray := strings.Split(string(file), "\n")
+	strArray = strArray[0:len(strArray)-1]
+
+	rand.Seed(time.Now().UnixNano())
+	for i := range strArray {
+		j := rand.Intn(i + 1)
+		strArray[i], strArray[j] = strArray[j], strArray[i]
+	}
+
+	/*for _, strln := range strArray {
+		s := strings.Split(strln," ")
+		strln = s[1]
+	}*/
+
+	for _, arg := range strArray {
+		s := strings.Split(arg," ")
+		arg = s[1]
+		if service, err = DJ.GetService(arg); err == nil {
+			tracks, err = service.GetTracks(arg, user)
+			if err == nil {
+				allTracks = append(allTracks, tracks...)
+			}
+		}
+	}
+
+	if len(allTracks) == 0 {
+		return "", true, errors.New(viper.GetString("commands.add.messages.no_valid_tracks_error"))
 	}
-	if length <= 2 {
-		return "", true, errors.New(viper.GetString("commands.shuffle.messages.not_enough_tracks_error"))
+
+	numTooLong := 0
+	numAdded := 0
+	for _, track := range allTracks {
+		if err = DJ.Queue.AppendTrack(track); err != nil {
+			numTooLong++
+		} else {
+			numAdded++
+			lastTrackAdded = track
+		}
 	}
 
-	DJ.Queue.ShuffleTracks()
+	if numAdded == 0 {
+		return "", true, errors.New(viper.GetString("commands.add.messages.tracks_too_long_error"))
+	} else if numAdded == 1 {
+		return fmt.Sprintf(viper.GetString("commands.add.messages.one_track_added"),
+			user.Name, lastTrackAdded.GetTitle(), lastTrackAdded.GetService()), false, nil
+	}
 
-	return viper.GetString("commands.shuffle.messages.shuffled"), false, nil
+	retString := fmt.Sprintf(viper.GetString("commands.add.messages.many_tracks_added"), user.Name, numAdded)
+	if numTooLong != 0 {
+		retString += fmt.Sprintf(viper.GetString("commands.add.messages.num_tracks_too_long"), numTooLong)
+	}
+	return retString, false, nil
 }
